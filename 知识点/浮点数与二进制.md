浮点数与二进制
===
这篇文章，主要说明一下，在编程语言中，是如何处理浮点数的，以及为什么会出现浮点数存在 ``0.1 + 0.2 = 0.30000000000000004`` 的现象

### IEEE 754
一套使用非常广泛的浮点数计算规则。Java,Python,Go,C... 非常多语言对于浮点数的计算都是符合这套标准的。

他是如何进行数据存储的呢，这个站点[IEEE Try](https://www.h-schmidt.net/FloatConverter/IEEE754.html)提供了非常直观的在线示例。

### 浮点数存储与舍入(精度丢失)
众所周知，在存储整数时，除了符号位需要特别处理以外，数字是通过除二取余的方式来转变为二进制的。如下图:
![Image text](https://raw.githubusercontent.com/liufeng3486/Documents/master/%E7%9F%A5%E8%AF%86%E7%82%B9/_static/screenshot/float_1.png)

因为最后是获取余数的所以，整数的存储是不存在数值的偏差的。

浮点数的存储是分成三分部分的。**整数部分** ，**符号部分** , **小数部分**。前面二者都比较正常，唯一问题比较大的，就是小数部分。

因为小数部分转为二级制的时候是采用 ``乘二取整`` 的方式来处理的。如下图：
![Image text](https://raw.githubusercontent.com/liufeng3486/Documents/master/%E7%9F%A5%E8%AF%86%E7%82%B9/_static/screenshot/float_2.png)
由此也看出，因为采用的是``乘二取整``所以必然会存在无法完整记录数据的情况，必然需要抛弃一部分数据。这就存在一个舍入的问题。就是我们平时所说的四舍五入。IEEE中一共有以下几种舍入方式:

|Mode/Example Value|+11.5|+12.5|−11.5|−12.5|
|:----|:----|----|:----|:----|
|to nearest, ties to even|+12.0|+12.5|−11.5|−12.5|
|to nearest, ties away from zero|+12.0|+13.0|−12.0|−13.0|
|toward 0|+11.0|+12.0|−11.0|−12.0|
|toward +∞|+12.0|+13.0|−11.0|−12.0|
|toward −∞|+11.0|+12.0|−12.0|−13.0|

既然舍弃了一部分多余的数据，不论他们多么的小，都会造成数据的不一致性。所以会存在``0.1 + 0.2 = 0.30000000000000004``的现象发生。

由于IEEE存在多种舍入方式，而除此之外，还存在着 (encoded with 32, 64 or 128 bits)的区别。所以在各个语言设置是同一个语言的各个版本中，对于该种数据的表现形式存在不一致的情况。

### 如何保证浮点数的精度
在一部分的情况下，特别是涉及到金额相关的时候，这种数据不一致的情况会非常的头疼。既然是问题，那么就需要解决它。

**使用第三方库/其他数据类型**
不论是JAVA的BigDecimal，还是PYTHON的decimal，或者是PHP的BC Math....总之大部分后端语言都或多或少会有着这些现成的轮子来处理这种问题。
主要是方式其实两种：
* 1.可以根据具体的需要来配置舍入的策略
* 2.增加数据长度，降低精度丢失的影响程度

**乘10取整**
有些情况下，是为了获得一个存在可以容忍范围内无误差的数。

其实就是已经规定了好舍入的方式，并且对数据精度并没有高的要求。

这个时候，一般的做法是 通过 *10^N 的方式，将需要的小数位数转变为整数进行计算。之后需要的规则进行舍入小数部分。再将结果%10^N来获取需要的数值。

Python演示代码
```python
>>> a=22.23
>>> b=24.33
>>> a-b
-2.099999999999998
>>> (int(a*100-b*100))/100.0  #int()将浮点类型转为整数类型
-2.1
```

**手动设置预期值范围**
在进行明确知道预期结果比对的时候。 避免一下的比对方式

Python演示代码
```python
>>> a = 0.3-0.1-0.1-0.1
>>> a
-2.7755575615628914e-17
>>> a==0
False
```

改用手动设置预期值范围的方式

```python
>>> a = 0.3-0.1-0.1-0.1
>>> abs(a-0)<0.000001   #abs()计算绝对值
True
```


